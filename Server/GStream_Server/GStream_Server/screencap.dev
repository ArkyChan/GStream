/*
	FILE *fp;
	fp = fopen("C:\\GStream\\yay.data", "wb");

	int stride = (Bitmap.bmWidth * (24 / 8) + 3) & ~3;
	std::cout << "Width: " << Bitmap.bmWidth << " Height: " << Bitmap.bmHeight << " Stride: " << stride << std::endl;

	//char red, green, blue,alpha;
	char* pCurrPixel = (char*)pixel;
	size_t start = clock();
	for(int i=0;i<Bitmap.bmWidth*Bitmap.bmHeight;i++){
		char d[] = {pCurrPixel[2],pCurrPixel[1],pCurrPixel[0]};
		fwrite(&d, 3, 1, fp);
		pCurrPixel+=3;
	}
	size_t t = clock() - start;
	std::cout << "Took " << t << "ms to loop the data" << std::endl;
	//fwrite(&pCurrPixel, 3, stride, fp);

	for (int y = 0; y < Bitmap.bmHeight; y++ )
	{
		for (int x = 0; x < Bitmap.bmWidth; x++ )
		{
			red = pCurrPixel[2];
			green = pCurrPixel[1];
			blue = pCurrPixel[0];

			fwrite(&red, sizeof(char), 1, fp);
			fwrite(&green, sizeof(char), 1, fp);
			fwrite(&blue, sizeof(char), 1, fp);
			pCurrPixel += 3;
		}
	}

	fclose(fp);

	std::cout << "Wrote data yay :D !" << std::endl;
	
	return NULL;
	
	HBITMAP b = capScreen(this->inf);
	size_t len = this->inf.w*this->inf.h*this->inf.bpp;
	unsigned char* data = (unsigned char*)malloc(len);
	GetBitmapBits(b,len,data);
	DeleteObject(b);
	return data;
	
	Method 2.
	HBITMAP b = capScreen(this->inf);
	BITMAPINFO  bmi;
	memset(&bmi, 0, sizeof(BITMAPINFO));
	bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	if(0 == GetDIBits(this->hDC, b, 0, 1, NULL, (BITMAPINFO *)&bmi, DIB_RGB_COLORS)){
	std::cout << "Failed to get BITMAPINFO" << std::endl;
	return 0;
	}
	unsigned char* data = (unsigned char*)malloc(this->inf.w*this->inf.h*this->inf.bpp);
	if(bmi.bmiHeader.biBitCount <= 8){
	GetDIBits(this->hDC,b,0,bmi.bmiHeader.biHeight,data,&bmi,DIB_RGB_COLORS);
	}
	else{
	GetBitmapBits(b,this->inf.w*this->inf.h*this->inf.bpp,data);
	}
	return data;

	
	Method 3.
	unsigned char* data = (unsigned char*)malloc(this->inf.w*this->inf.h*this->inf.bpp);
	GetObject(capScreen(this->inf),this->inf.w*this->inf.h*this->inf.bpp,data);
	return data;

	
	Method 4
	HBITMAP b = capScreen(this->inf);
	size_t size = this->inf.w*this->inf.h*this->inf.bpp;
	BITMAPINFO  bmi;
	memset(&bmi, 0, sizeof(BITMAPINFO));
	bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	if(0 == GetDIBits(GetDC(0), b, 0, 1, NULL, (BITMAPINFO *)&bmi, DIB_RGB_COLORS)){
	std::cout << "Failed to get BITMAPINFO" << std::endl;
	return 0;
	}
	VOID** data = 0;
	BITMAP bm;
	if(0 == CreateDIBSection(this->hDC,&bmi,DIB_RGB_COLORS,data,0,bmi.bmiHeader.biSize)){
	std::cout << "System error: " << GetLastError() << std::endl;
	}
	if(!GetObject(b,sizeof(BITMAP), &bm)){
	std::cout << "Could not load image" << std::endl;
	}else {
	return (unsigned char*)bm.bmBits;
	}
	
	size_t size = this->inf.w*this->inf.h*this->inf.bpp;
	this->hDC = GetDC(this->inf.handle);
	this->hDest = CreateCompatibleDC(this->hDC);
	HBITMAP hbDesktop = CreateCompatibleBitmap(this->hDC, this->inf.w, this->inf.h);
	BITMAP bmpScreen;
	GetObject(hbDesktop,sizeof(BITMAP),&bmpScreen);   
	return (unsigned char*)bmpScreen.bmBits;*/